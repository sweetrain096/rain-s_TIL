# Computational Thinking



+ inclusive or : 둘 중 하나 +  둘 다 가능
+ exclusive or : 둘 중 하나만.



### 논리 연습

+ 문제 1
  + 만약 0이 홀수라면, 미국에서 2020년 월드컵이 열린다.
    + p : 0이 홀수 : 거짓
    + q : 미국에서 2020년 월드컵 열린다. : 알 수 없음
    + p -> q 에서 p가 거짓이면 q가 거짓이든 참이든 모두 참이다.
  + 만약 1239029581905823571234891057820940923가 소수라면, 2는 짝수이다.
    + p : 알 수 없음
    + q : 참
    + 대우인 ~q -> ~p 일 때 2가 홀수이다가 거짓. 따라서 ~p의 참/거짓 여부에 상관없이 참.
+ 



+ 항진명제 : 항상 참인 명제





### 수와 표현

#### bit와 byte

+ bit : 0 / 1

+ byte : 영문자 한 자를 나타낼 수 있는 단위

  ​	: 8bit = ASCII(7bit) + parity bit(오류검출)

+ unicode : 2byte

+ KB = 2^10Byte



### bit로 값 표현

1. 부호와 절대치

   3비트로 표현

   ```
   0 0 0 		+0
   0 0 1 		+1
   0 1 0 		+2
   0 1 1		+3
   1 0 0 		-0
   1 0 1		-1
   1 1 0 		-2
   1 1 1		-3
   ```

2. 1의 보수

   ```
   1 1 1 		-0
   1 1 0 		-1
   1 0 1		-2
   1 0 0		-3
   ```

3. 2의 보수

   ```
   1 0 0 0 	-0
     1 1 1 	-1
     1 1 0 	-2
     1 0 1		-3
     1 0 0 	-4
   ```

`logn`의 밑은 `2`

+ 어떤 값 n을 표현하기 위해서는 몇 개의 비트가 필요?

  + 2 ^k - 1 >= n 이 성립. 즉, 2^k >= n + 1
  + 같은 의미로 : k >= log(n + 1) => 약 log n비트가 필요
  + x = log n과 2^x = n은 같은 말

+ log n이란?

  + 2의 몇 승이 n이 되느냐의 답
  + n을 표현하는 데 몇 비트가 필요한가의 답
  + 1로 시작해서 계속 두 배를 할 때 몇 번 하면 n이 되느냐의 답
  + n을 2로 계속 나눌 때 몇 번 나누면 거의 1이 되느냐에 대한 답

  