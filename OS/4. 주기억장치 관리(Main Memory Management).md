# 4. 주기억장치 관리<br>(Main Memory Management)

## 4.1 메모리 역사

+ 메모리의 종류
  + Core memory
    + 원형 코일(?)에 자석물질을 발라 전기를 가하면 자장이 발생한다. (플레밍의 오른손법칙)에 따라 전기의 방향을 다르게 하여 자장을 기록한다.
  + 진공관 메모리
    + 50~60년대 사용.
    + core 메모리와 진공관 메모리 때에는 메모리가 아주 비싼 자원이었다.
  + 트렌지스터 메모리 
    + 70~80년대
  + 집적회로 메모리
    + SRAM :캐시 저장
    + DRAM : 메인 메모리
+ 메모리의 용량
  + 1970년대 : 8bit PC, 64KB
  + 1980년대 : 16bit IBM-PC, 640KB -> 1MB -> 4MB
  + 1990년대 : 수 MB -> 수십 MB
  + 2000년 ~ 현재 : 수백 MB -> 수 GB
+ 그러나 언제나 부족한 메모리(메모리의 양이 많이 늘었지만 여전히 부족하다)
  + 프로그램 사이즈가 커졌다.
    + 기계어 / 어셈블리어 :arrow_right: C언어 :arrow_right: 자바, 객체지향형 언어
  + 처리 데이터가 커졌다.
    + 숫자 처리 :arrow_right: 문자 처리 :arrow_right: 멀티미디어 처리 :arrow_right: Big Data
+ 메모리 용량 증가 vs 프로그램 크기 증가
  + 메모리 용량이 증가하는 속도에 맞추어(어쩌면 더 빠르게) 프로그램 크기가 증가한다.
+ *어떻게 메모리를 효과적으로 사용할 수 있을까?*
  + **메모리 낭비 없애기**
  + **가상 메모리(virtual memory)**
    + 물리 메모리는 작으나 커보이게 만들어서 사용하는 방법





## 4.2 메모리 주소

### 프로그램 개발과 개발도구

+ CPU와 Memory 사이에는 주소(address)와 데이터(Data)를 주고 받는다.

  + 주소 : CPU에서 위치 접근
  + 데이터 : 쌍방향. 읽고 쓰기

  <img src="img/4-2.jpg" alt="4-2" style="zoom:50%;" />

+ 프로그램 개발

  + 원천 파일 (Source file) : 고수준 언어 또는 어셈블리 언어
  + 목적 파일 (Object file) : 컴파일 또는 어셈블 결과
  + 실행 파일 (Executable file) : 링크 결과

+ 개발 도구

  + 컴파일러 (Compiler) 
    + C언어 등의 고수준 언어를 목적파일로 변환해주는 도구
    + 목적파일은 1010000 모양의 기계어 등으로 표현된다.
  + 어셈블러 (assembler)
    + 어셈블리 언어를 목적파일로 변환해 주는 도구
  + 링커 (Linker)
    + 컴파일러나 어셈블러를 거쳐온 목적파일, 라이브러리로 부터 만들어진 파일들을 하나로 묶어 exe 파일을 만드는 도구
  + 로더 (loader)
    + 실행 파일을 메인 메모리에 올리는 도구

  <img src="img/4-2-develop-exe.jpg" alt="4-2-develop-exe" style="zoom:50%;" />



### 실행파일을 메모리에 올리기

+ 실행파일을 메모리에 올리려면?

  + 메모리 몇번지에 올릴것인가?
    + 프로그램이 하나씩만도는 싱글 프로그래밍 환경에서는 하나의 프로세스를 실행한 후, 종료하면 다른 프로그램을 실행시키면 된다.
  + 다중프로그래밍 환경에서는 어떻게?
    + 여러개의 프로세스가 메모리에 올라갈것이다. 
    + 하지만 CPU는 주소가 0번(O/S마다 다르다)이어야만 프로세스를 실행시킬 수 있다.
    + MMU를 사용하자!

+ MMU 사용

  + MMU에는 재배치 레지스터(relocation register)라는 레지스터가 존재한다.
  + CPU는 프로세스가 0번에 있다고 생각하지만 실제로는 메모리 주소 1000번에 존재한다. 이렇게 CPU를 착각하게 만든다.

+ 주소 구분

  + 논리 주소 (logical address) : CPU에서 memory로 향하는 주소. MMU 거치기 전
  + 물리 주소 (physical address) : MMU를 거쳐 나온 실제 메모리에 저장된 주소.

  <img src="img/4-2-MMU.jpg" alt="4-2-MMU" style="zoom:33%;" />







## 4.3 메모리 낭비 방지

+ Dynamic Loading
+ Dynamic Linking
+ Swapping



### 4.3.1 동적 적재 (Dynamic Loading)

+ Load : 하드디스크에 있는 프로그램(실행파일)을 메모리(RAM)에 올리는 것.

+ 프로그램 실행에 반드시 필요한 루틴/데이터만 적재한다.

  + 모든 루틴(routine)(=함수)가 다 사용되는 것은 아니다.

    + 예) 오류처리.

    + ```sudo
      f = file.open("test.txt")
      
      if f == NULL:
      	뭔가 처리하는 코드코드코드
      	return
      else:
      	뭔가 실행하는 코드코드코드
      ```

      위의 수도코드에서 파일이 NULL (== 존재하지 않는 파일, 잘못된 파일)인 경우 오류를 처리하는 코드가 돌게 된다.

      그러나 오류가 항상 생기는 것은 아니다. 일반적으로는 정상작동함.

      <b>때문에 오류가 발생한 경우에만 오류 실행 코드를 올린다.</b>

  + 모든 데이터(data)가 다 사용되는 것은 아니다.

    + 예) 배열
    + 실제로 사용하는 양은 10개의 공간만 있으면 되는데 1000개씩 생성하는 경우.

  + 자바 : 모든 클래스가 다 사용되는 것은 아니다.

    + 실행하기 전에 사용할 클래스들을 import 해야 하는데, 특정 함수만 골라서 import 하기 귀찮기 때문에 *로 모두 import 하는 경우

+ <b>실행 시 필요하면 그 때 해당 부분을 메모리에 올린다.</b>

+ 현재 사용하는 방법은 동적적재.

+ cf. 정적 적재(Static loading) : 과거에는 모두 메모리에 올렸다.





### 4.3.2 동적 연결(Dynamic Linking)

+ 여러 프로그램에 공통 사용되는 라이브러리(common library)를 한 번만 메모리에 올리는 방법
  + 공통 라이브러리 루틴(Library routine)을 메모리에 중복으로 올리는 것은 낭비이다.
    + ex) process 1과 process 2에서 모두 printf 함수를 사용할 때, printf 함수를 한 번만 메모리에 올린다면 메모리를 printf 함수 한 번 적재하는 것 만큼 아낄 수 있다.
  + 이를 위해 라이브러리 루틴 연결(링크)을 실행시까지 미룬다.
    + 링크는 기본적으로 실행파일을 만들기 전에 이루어진다.
    + 동적 연결에서는 이 `링크`를 실행되기 전까지 미룬다.
  + 오직 하나의 라이브러리 루틴만 메모리에 적재하고, 다른 애플리케이션 실행 시 이 루틴과 연결(link)한다.
  + ![동적 연결과 정젹 연결의 차이](img/Dynamic-Linking.jpg)
+ 공유 라이브러리(Shared Library) : Linux
+ 동적 연결 라이브러리(Dynamic Linking Library) : Windows
  + DLL파일이 이러한 동적 연결 라이브러리





### 4.3.3 스와핑 (Swapping)

+ 메모리에 적재되어있으나, 현재 사용되지 않고 있는 프로세스 이미지를 다른 영역(하드디스크 등)에 몰아내어 빈 메모리를 활용하는 방법
  + if) 파일을 다운받으면서 문서 작업 중, 잠시 자리를 비우게 되면 문서 작업 프로세스는 사용되지 않는다.
  + 이 때, 문서 작업 프로세스를 하드디스크 등의 공간(이것을 `backing store`라 한다.)에 몰아낸다.
  + 몰아내진 문서 작업 프로세스는 실제 하드디스크에 있는 문서 작업 프로그램과는 다르다.
  + 이를 구분하기 위해 하드디스크를 일부 잘라서, 현의 문서 작업 프로세스의 이미지를 저장한다.
+ Swap-out vs Swap-in
  + Swap out : 프로세스를 몰아내는 것.
  + Swap in : 몰아내 진 프로세스를 다시 메모리에 넣는 것.
+ Backing Store (swap device) : swap out 된 프로세스들이 저장될 공간.
  + 일반적으로 하드디스크의 공간을 일부 잘라서 사용한다.
  + 자신의 메인 메모리 크기만큼 둘 수 있다. 그러나 슈퍼컴퓨터의 경우에는 따로 저장장치를 두기도 한다.
  + 일반 프로그램들이 저장되는 공간은 file system이라고 부른다.
  + ![backing-store](img/backing-store.jpg)
+ Swap in 되는 경우, MMU의 Relocation register를 사용하여 새로 적재되는 위치는 이전과 무관하다.
+ 프로세스의 크기가 크면, backing store 입출력에 따른 부담이 크다.



















