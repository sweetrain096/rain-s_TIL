# 3. 프로세스 동기화<br>(Process synchronization)

+ 프로세스 동기화.
+ 스레드 동기화(Thread synchronization)라고도 부를 수 있다.
  + 엄연히 현대는 스레드를 기준으로 한 스위칭 방법을 사용한다.



## 3.1 Cooperating Processes

+ 프로세스는 `Independent` 한 프로세스와 `Cooperating`한 프로세스로 구분된다.
  + Independent : 각 프로세스 사이에 연관, 영향을 주지 않는다. 각각이 독립적 프로세스
  + Cooperating : 연관, 영향을 미치는 프로세스. 일반적으로 cooperating process가 많다.
    + cooperating process : 시스템 안 하나의 프로세스가 다른 프로세스에게 영향을 받거나, 미치는 경우, 그 프로세스.
  + 프로세스간 통신 : 전자우편, 파일 전송(파일/메일을 보내기, 받기)
  + 프로세스간 자원 공유 : 메모리 상의 자료들, 데이터 베이스 등
  + cooperating 예시
    + 명절 기차표 예약 : 만약 여기서 동기화가 일어나지 않으면 한 자리에 여러명이 예약 가능
    + 온라인 수강신청
    + 온라인 주식 거래 등



### Process Synchronization

+ 왜 하는가, 이유?

  + 공유 데이터에 동시에 접근하면 데이터가 일치하지 않을 수 있다. == 이상해 질 수 있다.
    + 위의 명절 기차표 예약처럼, 동기화가 일어나지 않으면 한 자리를 놓고 여러명이 예약 성공하는 경우가 나타날 수 있다.
  + 서로 영향을 주고 받는 프로세스에 순서를 잘 정해서 이상 상태가 되지 않고 데이터의 일관성을 유지할 수 있게 만든다.

+ EX) 은행 계좌 문제.

  + 부모는 은행 계좌에 입금, 자녀는 출금. 입금(deposit)과 출금(withdraw)는 독립적으로 일어난다.

  + ```java
    class Test {
        public static void main(String[] args)
        throws InterruptedException {
            BankAccount b = new
            BankAccount();
            Parent p = new Parent(b);
            Child c = new Child(b);
            p.start();
            c.start();
            p.join();
            c.join();
            System.out.println( "\nbalance = " + b.getBalance());
        }
    } 
    
    class BankAccount {
        int balance;
        void deposit(int amount) {
        	balance = balance + amount;
        }
        void withdraw(int amount) {
        	balance = balance - amount;
        }
        int getBalance() {
        return balance;
        }
    }
    
    class Parent extends Thread {
        BankAccount b;
        Parent(BankAccount b) {
        	this.b = b;
        }
        public void run() {
            for (int i=0; i<100; i++)
                b.deposit(1000);
    } 
        
    class Child extends Thread {
        BankAccount b;
        Child(BankAccount b) {
        	this.b = b;
        }
        public void run() {
            for (int i=0; i<100; i++)
                b.withdraw(1000);
        }
    } 
    ```

    위의 코드에는 시간지연 없음. 따라서 실행하면 결과값이 0이 나오게 됨. 

    같은 횟수로 1000원씩 입금과 출금이 일어나기 때문

  + but 시간지연을 추가하게 되면 잘못된 결과값이 나온다.

    + 실제로 시간지연을 추가하지 않더라도 낮은 확률로 결과값이 이상한것을 찾을 수 있다.
    + high level language를 어셈블리어로 변환하는 순간에 balance 값을 수정하는 순간이 발생할 수 있다. 
    + 0이 아닌 이상한 양수 또는 음수가 출력.
    + 이유 : 공통 변수(common variable)에 대한 동시 업데이트(concurrent update)
    + 해결 : 한번에 한 쓰레드만 업데이트 하도록 -> **임계구역 문제**
      + 공통 변수 업데이트 코드를 atomic하게(하나의 원자처럼 분리하지 않고 묶어서) 다룬다.



## 3.2 임계 구역(Critical Section) 문제

### critical section

+ Critical Section(임계 구역)

  + 여러개의 스레드(프로세스)로 이루어진 시스템에서, 각 스레드는 코드 영역을 가지고 있는데, **공유 자원(표, 파일 등)을 바꾸거나, 업데이트, 쓰기 등을 공유 코드 영역**을 *Critical Section*이라고 한다.

  + 위의 은행 계좌 문제에서 공유 자원인 *balance*를 수정하는 코드를 critical section이라고 한다.

    + ```java
      class BankAccount {
          int balance;
          void deposit(int amount) {
          	balance = balance + amount;	// critical section
          }
          void withdraw(int amount) {
          	balance = balance - amount;	// critical section
          }
          int getBalance() {
          return balance;
          }
      }
      ```

+ Critical Section Problem

  + **임계 구역(critical section)에 있는 코드가 동시에 업데이트** 되어 결과값이 이상해지는 것.

+ 해결 방법

  + 아래의 3가지 조건을 만족해야한다.

  1. Mutual exclusion (상호 배타) 
     + 한 스레드에서 critical section에 진입하면 다른 스레드에서는 진입할 수 없다.
     + 많아야 한 스레드만 진입한다.
     + ex) parent 스레드에서 balance 값을 변경하는 critical section에 진입하면, child 스레드는 끝날때까지 대기해야한다.
  2. Progress (진행)
     + 누가 먼저 critical section에 들어갈지 유한시간 내에 결정해야한다.
  3. Bounded waiting (유한 대기)
     + 기다리고 있는 한, 어느 스레드라도 유한 시간 내에 진입할 수 있다.

+ 이 임계 구역 문제를 해결하기 위해서는 **프로세스/스레드** 동기화가 필요하다.



### 프로세스/스레드 동기화

+ O/S의 역할

  1. process mgmt
     1. CPU scheduling
     2. Process synchronization
  2. memory mgmt
  3. file system
  4. I/O system
  5. ...

  + 위에서 볼 수 있듯 O/S의 process management 부분에서는 크게 CPU 스케쥴링과 프로세스 동기화를 중요하게 다룬다.

+ 프로세스/스레드 동기화를 하는 이유

  + 임계 구역 문제 해결
    + 이상한 답이 나오지 않도록 문제를 해결한다.
    + 상호배타, 진행, 유한 대기의 3가지 조건을 모두 만족시킨다.
  + 프로세스 실행 순서 제어
    + 우리가 원하는대로 프로세스 안의 스레드 실행 순서를 제어할 수 있다. 





