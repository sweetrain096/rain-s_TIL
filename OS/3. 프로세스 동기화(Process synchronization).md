# 3. 프로세스 동기화<br>(Process synchronization)

+ 프로세스 동기화.
+ 스레드 동기화(Thread synchronization)라고도 부를 수 있다.
  + 엄연히 현대는 스레드를 기준으로 한 스위칭 방법을 사용한다.



## 3.1 Cooperating Processes

+ 프로세스는 `Independent` 한 프로세스와 `Cooperating`한 프로세스로 구분된다.
  + Independent : 각 프로세스 사이에 연관, 영향을 주지 않는다. 각각이 독립적 프로세스
  + Cooperating : 연관, 영향을 미치는 프로세스. 일반적으로 cooperating process가 많다.
    + cooperating process : 시스템 안 하나의 프로세스가 다른 프로세스에게 영향을 받거나, 미치는 경우, 그 프로세스.
  + 프로세스간 통신 : 전자우편, 파일 전송(파일/메일을 보내기, 받기)
  + 프로세스간 자원 공유 : 메모리 상의 자료들, 데이터 베이스 등
  + cooperating 예시
    + 명절 기차표 예약 : 만약 여기서 동기화가 일어나지 않으면 한 자리에 여러명이 예약 가능
    + 온라인 수강신청
    + 온라인 주식 거래 등



### Process Synchronization

+ 왜 하는가, 이유?

  + 공유 데이터에 동시에 접근하면 데이터가 일치하지 않을 수 있다. == 이상해 질 수 있다.
    + 위의 명절 기차표 예약처럼, 동기화가 일어나지 않으면 한 자리를 놓고 여러명이 예약 성공하는 경우가 나타날 수 있다.
  + 서로 영향을 주고 받는 프로세스에 순서를 잘 정해서 이상 상태가 되지 않고 데이터의 일관성을 유지할 수 있게 만든다.

+ EX) 은행 계좌 문제.

  + 부모는 은행 계좌에 입금, 자녀는 출금. 입금(deposit)과 출금(withdraw)는 독립적으로 일어난다.

  + ```java
    class Test {
        public static void main(String[] args)
        throws InterruptedException {
            BankAccount b = new
            BankAccount();
            Parent p = new Parent(b);
            Child c = new Child(b);
            p.start();
            c.start();
            p.join();
            c.join();
            System.out.println( "\nbalance = " + b.getBalance());
        }
    } 
    
    class BankAccount {
        int balance;
        void deposit(int amount) {
        	balance = balance + amount;
        }
        void withdraw(int amount) {
        	balance = balance - amount;
        }
        int getBalance() {
        return balance;
        }
    }
    
    class Parent extends Thread {
        BankAccount b;
        Parent(BankAccount b) {
        	this.b = b;
        }
        public void run() {
            for (int i=0; i<100; i++)
                b.deposit(1000);
    } 
        
    class Child extends Thread {
        BankAccount b;
        Child(BankAccount b) {
        	this.b = b;
        }
        public void run() {
            for (int i=0; i<100; i++)
                b.withdraw(1000);
        }
    } 
    ```

    위의 코드에는 시간지연 없음. 따라서 실행하면 결과값이 0이 나오게 됨. 

    같은 횟수로 1000원씩 입금과 출금이 일어나기 때문

  + but 시간지연을 추가하게 되면 잘못된 결과값이 나온다.

    + 0이 아닌 이상한 양수 또는 음수가 출력.
    + 이유 : 공통 변수(common variable)에 대한 동시 업데이트(concurrent update)
    + 해결 : 한번에 한 쓰레드만 업데이트 하도록 -> **임계구역 문제**

