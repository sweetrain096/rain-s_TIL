# 운영체제 공부

## 1.1 운영체제의 정의

### 운영체제(operating system = OS)란?

+ 컴퓨터 하드웨어(프로세서, 메모리, 디스크 등)을 잘 관리하여 큰 두가지 목적을 달성하는 프로그램
  1. 성능을 높인다.
     + 같은 하드웨어라도 os가 좋으면 더 좋게 사용 가능하다
  2. 사용자에게 편의성을 제공한다.
     + GUI 환영으로 쉽게 사용자가 접근 가능하다
+ 쉽게 말하면 컴퓨터 하드웨어를 관리하는 프로그램이다.



### 운영체제가 없다면?

+ 컴퓨터는 크게 프로세서와 메모리로 존재한다. 메모리는 각 순서에 따라 프로그램을 적재하고 실행시키는데 이 체계적인 순서가 사라진다.
+ 사용자가 프로그램을 사용할 때에는 하드디스크에 있는 프로그램을 메모리로 올려서 사용하게 되는데, os가 없다면 메모리로 올릴 수 없다.
+ 마찬가지로 여러개의 프로그램을 동시 실행시킬수도 없다.
+ 프린터도 사용 불가하며, 하드디스크에 저장도 불가하다.

<b>os가 없으면 메모리 안에는 임의의, 멋대로 들어있는 엉터리 값들이 존재한다. 사용이 불가능 한 상태의 폭주하는 컴퓨터가 되버린다.</b>



### 운영체제의 역할

+ 하드웨어를 관리하는 역할을 주로 한다.
+ 또한 사용자의 의도대로 프로그램을 실행시켜주는 명령 해석기의 역할을 한다.



### 운영체제의 시작 위치 (BOOT)

+ 컴퓨터의 메인 메모리에는 휘발성 메모리인 RAM과 비휘발성 메모리인 ROM이 존재한다. 컴퓨터에 전원이 들어오게 되면 프로세서는 가장 먼저 ROM을 읽게된다.
  1. POST(power-on self-test)프로그램을 실행한다.
     + 컴퓨터에 이상이 있는지 사용 환경을 체크한다.
  2. 부트로더(Boot loader)
     + 하드디스크에 설치되어 있는 os의 위치를 찾아 메인 메모리 RAM으로 가져온다. 
     + 이 과정을 부팅이라고 한다.
+ 부팅이 되면 각 os에 맞는 화면이 뜨게 된다. 윈도우라면 바탕화면과 아이콘, 리눅스라면 로그인 화면 등이 뜨게 된다.
+ os가 RAM에 올라오면 언제 사라질까?
  + 다른 프로그램들은 실행시 RAM에 올라가고 종료시 사라지게 된다.
  + 그러나 OS는 부팅 시 RAM에 올라오게 되며 전원이 끊어질 때 사라지게 된다.
    + 이 때문에 OS를 메모리의 resident라 부른다.



### 운영체제 = kernel + shell

+ 운영체제는 kernel과 shell로 이루어져있다.
+ kernel : 하드웨어와 밀접하게 관계있으며, 직접 하드웨어를 관리한다.
+ shell(명령해석기(command interpreter)) : 사용자의 명령을 받고 해석해 해당 명령을 실행한다.



+ 일반적으로 '운영체제를 사용한다', '운영체제를 안다'고 하는 것은 shell의 사용을 말하는 것이며, 이 강의에서는 shell이 아닌 kernel의 사용을 공부할것이다.



### 운영체제의 위치

+ 운영체제는 하드웨어 -> 운영체제 -> 애플리케이션 순으로 나열할 수 있다.
+ 과녁판과 같은 모양의 한 가운데가 하드웨어, 그 바깥쪽이 운영체제, 그 바깥쪽을 어플리케이션이 차지한다.



### 운영체제와 정부의 유사점

+ 운영체제는 자원 관리자(resource manager) 또는 자원 할당자(resource allocator)라고 부른다.
+ 주어진 자원을 어떻게 가장 잘 활용할 지 계산하고 관리한다.
+ 운영체제가 직접 개입하지는 않지만, 각 자원을 어떻게 할당해야할지 계획하고 관리하게 된다.





## 1.2 운영체제의 역사

### 0. No O/S

+ 컴퓨터 구조 : 카드 리더 / 메모리 / 프로세서 / 프린터
+ 프로그래머가 연필로 프로그램을 작성하면 오퍼레이터가 카드를 만들어서 메모리에 올린다. 또한 프로그램이 실행될 수 있는 일련의 과정(컴파일 등...)을 오퍼레이터가 한다.
  + 오퍼레이터 : 컴퓨터를 사용할 수 있는 사람. 사람이 원하는 대로 프로그래밍 하기 위해 컴퓨터에게 해당 일을 수행할 수 있도록 만드는 직업
  + 컴파일 : 하이레벨 랭귀지(high-level language)를 기계어로 변환
+ 1940년대 ~ 50년대



### 1. Batch processing system (일괄처리시스템)

+ 컴퓨터 구조 : 카드 리더 / 메모리 / 프로세서 / 프린터
+ 오퍼레이터가 해야하는 작업(컴파일, 링커, 로딩 등)을 일괄적으로 묶어(batch) 프로그램으로 만든다. 이 프로그램을 메모리 안에 적재.
  + 다시 말하면, 컴파일, 링커, 로딩 등의 항상 하는 일을 메모리에 넣는다.
  + 이 일이 OS가 되며, 이것은 항상 상주하는 묶음의 일이기 때문에 **resident monitor** 라는 기술이라고도 한다.
+ 이 때 메모리에는 OS가 올라가며, 1개의 User 프로그램만 동작시킬 수 있다.



### 2. Multiprogramming system (다중프로그래밍 시스템)

+ 컴퓨터 구조 : 카드 리더 / 메모리 / 프로세서(cpu) / 프린터
+ 배경 : 하드디스크가 사용되고, 메인 메모리의 용량이 커지며 CPU의 속도가 빨라졌다. 그에 비해 I/O(입출력)은 느린 차이를 이용하게 된다.
+ 여러개의 user program을 사용할 수 있게 한다. 
  + 1개의 프로그램 실행 시 프로그램은 CPU(계산)과 I/O(입 출력)을 번갈아 사용하게 된다. I/O를 하는 동안 귀중한 자원인 CPU가 놀게되는데(== CPU idle), 이 순간에도 다른 프로그램을 실행시켜 CPU idle 시간을 줄인다.
  + 3개의 프로그램 실행 시,
    + 1번 cpu 사용 
    + 1번 i/o 사용 -> 2번 cpu 사용
    + 2번 i/o 사용 -> 3번 cpu 사용
    + 3번 i/o 사용 -> 1번 cpu 사용
  + 어느 순간에도 cpu가 놀지 못하도록 스위칭 하며 idle time을 줄인다.
+ 기술 발전 
  + CPU scheduling : 메인 메모리에 있는 user 프로그램 중 무엇을 먼저 실행하는 것 이 최고 성능일까?
  + 메모리 관리 : user 프로그램을 어떻게 둬야할까? 한칸씩 띄워가며 프로그램 메모리 주소를 줘야할까? 아예 다른 곳에 두는 게 좋을까?
  + 보호 : 여러개의 프로그램을 동시에 실행시키게 될 때, 같은 이름의 변수 사용등의 문제로 다른 프로그램에 영향을 미치게 되는 것을 막아야한다.



### 3. Time-sharing system (시공유 시스템)

+ 컴퓨터 구조 
  + 하나의 메인 컴퓨터 - 메모리 / 프로세서 / 등...
  + 여러개의 단말기(Terminal) - 모니터와 키보드만 존재. == 한명의 user
+ 배경 : 모니커와 키보드의 등장 = interactive system(대화형 시스템) 가능.
+ 여러명의 User가 사용 가능하게 한다.
  + 멀티프로그래밍을 활용하여 user를 할당하게 되면 cpu가 하나이기 때문에 한명이 cpu를 사용하는 동안에는 다른 user들은 컴퓨터를 사용하지 못한다.
  + 때문에 아주 짧은 시간동안 cpu를 할당하는 것을 반복하여 모든 user들이 동시에 컴퓨터를 하고 있는 것 처럼 만든다.
  + 1/100초 ~ 1/1000초에 한번 씩 user1, user2, user3, user1, user2, user3, ... 의 순서(는 바뀔 수 있음)로 스위칭하며 cpu를 할당한다. => 이 방법을 강제절환이라 한다.
+ 기술 발전
  + 가상 메모리 : 사용자가 많아지며 메인 메모리가 부족해진다. 이 때 하드디스크의 일부를 메인 메모리처럼 사용하는 방법이다.
  + 프로세스간 통신 : 하나의 컴퓨터 안에서 각각의 터미널을 연결하여 통신을 가능하게 한다.
  + 동기화(synchronizaton) : 어떤 것을 먼저 실행하고 나중에 실행할것인가?
+ TSS는 가장 최근까지도 사용되고 있는 운영체제이다.
+ ex) windows 7, 8, xp, ..., Unix(최초의 TSS), Linux(Unix이후버전) ,....





### OS 기술 변화

+ 컴퓨터 규모 별 분류
  + supercomputer > mainframe > mini > micro  => 70~80s 구분
  + Supercomputer > Server > Workstation > PC > Handheld > Embedded
    + Supercomputer : 요즘에도 사용된다. 기상청 은행 등 대규모 작업
    + Server : 하나의 네트워크에 여러개 존재한다. 대학교 수강신청 등의 규모 작업을 진행한다.  ex) DB server, Web server, Video server 등
    + Workstation : PC 보다 큰 규모의 작업을 하기 위해 존재한다.
    + PC : 우리가 사용하는 컴퓨터. 하나의 네트워크 아래에 아주 많은 수의 PC가 존재한다.
    + Handheld : 노트북, 태블릿 PC, 스마트폰 등
    + Embedded : 자동차, 밥솥, 냉장고, 세탁기 등 우리 눈에는 보이지 않지만 전자기기를 제어하는 역할을 한다.
+ 위에서 설명한 3가지의 os 시스템은 대규모 컴퓨터부터 순서대로 적용되며 pc, handheld 에도 적용되고, embedded 에도 적용되고 있다.





## 1.3 고등 운영체제

### 1. 다중 프로세서 시스템(Multiprocessor system)

+ 여러개의 CPU에 연결된 하나의 메모리.
+ 병렬 시스템(parallel system) : 여러개의 CPU가 병렬 연결되어있음
+ 강결합 시스템(tightly-coupled system) : 하나의 메모리에 CPU를 여러개 연결. == 이를 **강하게 결합했다**고 함
+ 장점
  1. perfomance : cpu가 여러개이기 때문에 성능이 향상된다.
  2. cost : 일반적으로 하나의 강한 cpu보다 여러개의 약한 cpu가 저렴하다.
     + 일반적으로 성능이 절반일 때 가격은 1/4이거나 더 낮은 경우가 많다.
  3. reliability : 하나가 고장나도 다른 cpu가 동작 가능하기 때문에 신뢰도가 높다.
+ **다중 프로세서 운영체제(Muliprocessor OS)**가 필요
  + 관리하는 것이나, 스케줄링 방법 등 다른 부분이 많이 존재.



### 2. 분산 시스템 (Distributed system)

+ 하나의 CPU와 하나의 memory로 이루어진 하나의 컴퓨터(?)가 LAN(근거리통신망)으로 연결.
+ 다중 컴퓨터 시스템(multi-computed system) : **CPU-메모리** 가 여러개.
+ 소결합 시스템(loosely-coupled system) : CPU 각각이 메모리 각각에 연결.
+ 장점
  1. perfomance : cpu가 여러개이기 때문에 성능이 향상된다.
  2. cost : 일반적으로 하나의 강한 cpu보다 여러개의 약한 cpu가 저렴하다.
     + 일반적으로 성능이 절반일 때 가격은 1/4이거나 더 낮은 경우가 많다.
  3. reliability : 하나가 고장나도 다른 cpu가 동작 가능하기 때문에 신뢰도가 높다.
+ **분산 운영체제(Distributed OS)**



### 3. 실시간 시스템(Real-time OS = RTOS[알토스])

+ 1, 2번과는 장점(목적)이 다르다.
+ 어떤 계산을 할 때, 그 계산이 제약 시간(deadline) 안에 끝나야 하는 시스템. 시간을 넘을 경우 실패한 계산이 된다.
  + 네비게이션에서, 교차로에서 이동 방향을 알려주지 못하고, 지나간 후에 교차로에서의 방향을 알려주는 것을 생각하면 쉽다.
+ 사용 예 : 공장 자동화(FA, Factory Automation), 군사, 항공, 우주





## 1.4 인터럽트 기반 시스템(Interrupt-Based system)

#### 현대 운영체제는 인터럽트 기반 시스템이다

+ 인터럽트 : 특정 이벤트가 발생했을 때, 그에 해당하는 동작을 실행하기 위해 다른것들을 멈추고 동작을 실행하는 것.
+ 현대 운영체제(OS)는 메모리에 상주하며 이 **인터럽트**(이벤트)를 기다린다.



### 하드웨어 인터럽트(Hardware Interrupt)

+ 마우스, 키보드 등의 전기 신호가 CPU에서 하드웨어 인터럽트를 일으킨다. 
+ 이 결과 운영체제 내의 특정 코드(Interrupt Service Routine, ISR)를 실행한다.
+ Interrupt Service Routine 종료 후 다시 대기한다.



### 소프트웨어 인터럽트(Software Interrupt)

+ SWI(소프트웨어 인터럽트)라는 명령어로 실행 가능하다.
+ 사용자 프로그램이 실행되면서 프린터, 하드디스크 등을 이용하기 위해 소프트웨어 인터럽트를 일으킨다.
+ 이 결과 운영체제 내의 특정 코드(ISR)를 실행한다.
+ ISR 종료 후 다시 사용자 프로그램으로 돌아간다.



### 내부 인터럽트(Internal Interrupt)

+ 프로그램 내부 사정 등으로 발생하는 인터럽트

+ ```c
  int i = 5;
  int j = 0;
  int calc = i / j;
  ```

  위 코드에서 3번째 줄은 5를 0으로 나눈 무한 값이 calc 안에 저장될 수 없다. 이러한 경우에는 프로그램이 더 이상 동작할 수 없기 때문에 인터럽트 발생으로 프로그램을 종료한다.



### 인터럽트 기반 운영체제

+ 운영체제는 평소에는 대기상태이다.
+ 운영체제를 사용하려면 인터럽트를 발생시켜야 한다.
  + 하드웨어 인터럽트
  + 소프트웨어 인터럽트
  + 내부 인터럽트
+ 인터럽트 서비스 루틴(Interrupt Service Routine, ISR)이 종료되면 원래의 대기상태 또는 사용자 프로그램으로 복귀한다.





## 1.5 이중모드(dual mode)

+ 관리자(OS) 모드에서만 사용될 수 있는 명령어와 사용자 프로그램에서 사용되는 명령어를 분리하는 것.
+ 컴퓨터를 보호하는 목적.



### 발생 이유

+ 배경
  + 한 컴퓨터를 여러 사람이 동시에 사용하는 환경
  + 한 사람이 여러 개의 프로그램을 동시에 사용
+ 원인
  + 한 사람의 고의 / 실수로 프로그램 전체에 영향을 미침
  + STOP, HALT, RESET 등의 명령어
+ 예
  + STOP 명령어는 CPU를 멈추게 하는 명령어로 CPU가 STOP 명령을 탈출하는 방법은 전원을 끄는 방법 뿐이다. 만약 여러명이 사용하는 서버 컴퓨터에서 이 상황이 발생한다면 작업하던 것을 모두 날려야 할 뿐 아니라 재부팅하는 데에도 오랜 시간이 걸린다.
+ 한 명의 user가 사용한 명령어 하나로 프로그램 전체에 영향을 미치지 않기 위하여 특별한 명령을 내릴 수 있는 **관리자 모드**와 사용할 수 없는 **사용자 모드**로 나눈다.



### 이중 모드

+ 사용자 모드와 관리자 모드로 나눈다.
  + 사용자 모드(user mode)
  + 관리자 모드(supervisor mode) == 시스템 모드(system mode) == 모니터 모드(monitor mode) == 특권 모드(priviliged mode)
+ 특권 명령(privileged instructions)
  + 관리자 모드에서만 사용할 수 있는 강력한 명령어
  + STOP, HALT, RESET, SET_TIMER, SET_HW, ...



### 이중 모드의 구분

+ 사용자 모드와 관리자 모드의 구분은 CPU안의 register의 한 비트로 표현된다.
  + CPU는 register, AMU(계산), CU(control unit)으로 이루어진다.
  + register에는 다음과 같은 flag들이 존재한다.
    + Carry : 더할 때 한 자리수 증가
    + Negative : 음수
    + Zero : 연산 결과가 0
    + overflow : 연산 결과가 자릿수를 넘김
  + 이중 모드의 구분은 이 flag들 중 하나인 **monitor bit**로 구분한다.
  + 1 : system mode
  + 0 : user mode



### 이중 모드의 플래그 변화

+ 운영 체제 서비스 실행 시 관리자 모드 : 1
  + OS가 하드 디스크에서 게임을 불러와서 메모리에 올릴 때 까지. 이후 flag 0으로 변화
+ 사용자 프로그램 실행 시 사용자 모드 : 0
  + 프로그램이 실행되면 flag 1
+ 하드웨어/소프트웨어 인터럽트 발생 시 관리자모드 : 1
  + 마우스/키보드 입력 및 파일 읽기/저장 등의 인터럽트 발생 시 CPU에서 인터럽트 발생. flag 1. OS에서 ISR 실행 된 후 다시 flag 0
+ 운영체제 서비스가 종료 후 사용자 모드 : 0
  + ISR 종료 후 원래 사용하던 프로그램으로 돌아간 후 flag 0



**끊임 없이 user mode와 system mode를 반복하며 프로그램을 실행한다.**



### if, User mode에서 특권 명령 실행

+ 레지스터의 monitor bit를 확인하여, user mode인지 system mode인지를 구분.
+ user mode에서 명령이 발생했다면 (CPU로 명령) 명령을 실행하지 않고 OS로 인터럽트
+ 위와 같은 상황에 맞은 인터럽트를 OS에 요청하면 해당하는 ISR를 실행한다.
  + 일반적으로 이 경우에는 특권 명령을 실행한 프로그램을 강제 종료한다.







## 1.6 하드웨어 보호

+ 목적
  1. 입출력 장치 보호(Input/output device protection)
  2. 메모리 보호(Memory protection)
  3. CPU 보호(CPU protection)



### 1. 입출력 장치 보호

+ 발생 원인
  + 사용자의 잘못된 입출력 명령
  + 다른 사용자의 입출력, 정보 등에 방해
    + ex) 프린트 혼선, 리셋 등
    + ex) 다른 사람의 파일 읽고 쓰기(하드디스크)
+ 해결법
  + **입출력 명령을 특권 명령으로 : IN, OUT**
  + 입출력을 하려면 운영체제에게 요청하고 (system mode 전환)
    + 프로그램에서 s/w interrupt 발생.
  + 올바른 요청일 경우 운영체제가 입출력을 대행한다. 마친 후 user mode 복귀
    + ISR 실행. 종료 시 원래 프로그램으로 돌아간다.
  + 올바르지 않은 요청일 경우 운영체제가 거부한다.
    + ex) A가 작성한 파일을 B가 보려고 하면 거부.
    + 이것이 동작하기 때문에 네이버나 구글 클라우드를 활용할 수 있음
  + if, 사용자가 입출력 명령을 직접 내린 경우?
    + Privileged instruction violation
    + user 프로그램에서 cpu로 입출력 명령을 내릴 경우, 잘못된 명령이 들어왔다는 인터럽트 발생. OS에서 ISR 실행. 일반적으로 프로그램을 종료하는 ISR이 실행된다.



### 2. 메모리 보호

+ 발생 원인
  + 메모리 안에서 여러개의 프로그램이 동작할 때, 특정 프로그램(1번)이 다른 사용자 메모리(2번, 3번 등) 또는 운영체제 영역(OS) 메모리에 접근.
  + 실수/고의로 접근하게 되면 다른 사용자 정보/프로그램, 운영체제를 해킹하게된다.
+ 해결법
  + CPU에서 메모리로 접근하는 Address Bus에 **MMU(Memory Management Unit)를 두어 다른 메모리 영역 침범을 감시**한다. 해당하는 메모리 주소만 통과시킨다.
    + 프로그램에 cpu에게 요청하며 전달한 주소가 cpu에서 처리되고 돌아가는 주소와 맞는지 체크한다.
    + MMU는 레지스터 주소로 생각하면 편하다. base와 limit 두 주소값 사이에 들어오면 통과시키고 범위에 포함되지 않으면 인터럽트를 발생시킨다.
    + 이 때 base와 limit 값은 OS가 특권 명령으로 설정한다.
  + if, 다른 사용자 또는 운영체제 영역 메모리 접근 시도?
    + Segment violation
    + MMU를 통과하지 못한 경우, 인터럽트가 발생하며, ISR을 실행한다.



### 3. CPU 보호

+ 발생 원인
  + 한 사용자(프로그램)이 실수/고의로 CPU시간을 독점하는 경우
    + 주로 한 컴퓨터를 여럿이서 사용하는 경우 발생한다. 또는 여러개의 프로그램을 실행할 때에도 발생한다.
    + while(n = 1)과 같은 무한루프의 코드를 돌게 될 경우에 발생한다.
  + 다른 사람의 프로그램이 실행 불가하다.
+ 해결법
  + **Timer를 두어 일정 시간 경과 시 인터럽트를 발생시킨다.**
    + OS에서 ISR 실행한다. 어느 한 user에게 시간이 집중되고 있나, 시간이 잘 분배되고 있나, 무한루프가 발생했나 등을 체크한다.
    + 만약 한 프로그램에 시간이 CPU 시간이 집중되면 강제로 다른 프로그램을 실행한다.
  + 인터럽트 발생 -> OS에서 ISR 실행 -> 다른 프로그램으로 강제 전환





