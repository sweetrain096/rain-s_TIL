# 알고리즘 강의



## 프로그래밍 언어 설명

- ALGOL -> B -> C

- C : 데니스리치 만듦. UNIX 운영체제에서 전문가용.

  ​     포인터 존재

- java : OOP(객체지향) 안드로이드 프로그램

  ​	  SUN -> Oracle(DB만드는 회사)

  ​	  어느 플랫폼(윈도우, 리눅스 ...)에서든 돌아간다.

- C++ : 회사에서 만든것이 아님. MS에서 툴만 제공

- C# : MS에서 자바와 C++의 장점을 가지고 만들었다고 한 것.



- Visual Basic  

- Python : 인터프리터 언어. 개발이 쉽다. 

  ​		머신러닝이나 빅데이터 쪽에서 라이브러리를 잘 제공해서 많이 사용.

  ​		문법적으로 배우기 쉽다.

  ​		객체지향



---



인터프리터 언어 : 한 줄한줄 실행. 속도에서 느림. 

compile : 파일 전체를 변환시켜 실행. 속도는 컴파일러가 빠르다. 

스크립트 언어 : 브라우저(클라이언트쪽)에서 도는 언어(자바스크립트, html)

인터프리터 언어 중 서버에서 도는 언어 : jsp, asp, ...



---



프로그램 개발 절차 : 

1. 요구사항 분석 : 문제를 잘 읽어야한다. 제약조건이나 구해야 하는 값을 확인.

2. 설계 : 설계. 연필로 가장 작은 테스트케이스를 설계해 해결 할 건지 확인. 
3. 구현 :  코딩. language는 도구.
4. 테스트 
5. 유지보수 





## 알고리즘

**어떤 문제를 해결하기 위한 절차**

유한한 단계를 통해 문제를 해결하기 위한 절차나 방법. 컴퓨터가 어떤 일을 수행하기 위한 단계적 방법.





## 시간복잡도(Time Complexity)

실제 걸리는 시간을 측정.

실행되는 명령문의 개수를 계산



### 빅-오(O) 표기법

- (Big-Oh Notation)
- 시간복잡도 함수 중에서 가장 큰 영향력을 주는  n에 대한 항만을 표시
- 계수는 생략하여 표시



​	ex) for 1개 : n

​	for 2개 : 2n == n

​	2개 중첩 for : n^2



- O(1) : 수식 한개. or 수식 몇 줄. 반복문 X

-  O(n) : 순차탐색 : 순서대로 모두 체크 for1개

- O(logn) : 이진탐색 : 이분법적으로 반씩 나누고 아닌것은 버리기. 

  ​					ex) 1~100 => 50~100 => 50~75 

- O(n^2) : 선택, 버블, 삽입(하나 잡아서 체크) => for가 중첩으로 2개 

- O(nlogn) : 퀵소트, 병합, heap

- O(n^3) : 프로이드 알고리즘. 모든 최단경로

- O(2^n) : 부분집합. 

- O(n!) : 순열. 숫자를 가지고 나열할 수 있는 모든 경우의 수.









###

 HDD : 필요한 코드 생성

RAM : 올리기

CPU : 받아온 코드 실행 

RAM : 일부 변수 저장

HDD : 휘발성 내용이 아닌 저장할 부분을 저장.





## 완전검색(Exaustive Search)

- 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법

- **모든 경우의 수를 테스트 한 후 최종 해법을 도출.**

- 경우의 수가 작을 때 유용

- 모든 경우의 수를 생성하고 테스트 하기 때문에 수행 속도는 느리지만 해답을 찾아내지 못할 확률이 작다.

- 완전검색으로 접근하여 해답을 도출 한 후 성능 개선을 위해 다른 알고리즘을 사용하기.



### 순열

서로 다른 것 들 중에서 몇개를 뽑아서 한 줄로 나열하는것

중복 뽑기XXX

서로 다른 n개중 r개를 택하는 순열 nPr = 

npn = n!





## 탐욕(Greedy) 알고리즘

최적해를 구하는 데 사용되는 근시안적인 방법

여러 경우 중 하나를 결정해야 할 때 그 순간에 최적이라고 생각되는 것을 선택해 나가는방식

결정은 그 단계에서는 최적이지만 전체에서는 아닐 수 있다.

일반적으로 머릿속에 떠오르는 생각을 바로 구현하면 Greedy 접근이 된다.

### 동작과정

1. 해 선택 : 현재 최적 해 구하기
2. 실행 가능성 검사: 새로운 부분 해 집합이 실행 가능한 지 확인
3. 해 검사 : 새로운 부분 해 집합이 문제의 해인지 확인. 









## 정렬

### 버블정렬

인접한 두 개의 원소를 비교하여 자리를 계속 교환하는 방식

#### 정렬 과정

1. 첫 번째 원소부터 인접한 원시끼리 계속 자리를 교환하면서 맨 마지막 자리까지 이동.
2. 한 단계가 끝나면 가장 큰 원소가 마지막 자리로 정렬.

#### 시간복잡도 

: O(n^2) => for 2개가 중첩될 것.







#### **파라미터를 부르는 방법**

- call by value : 복사 => 변수 하나
- call by reference : 원본 참조 => list : 함수 안에 들어갔다가 오면 바뀔 수 있다.





### 카운팅 정렬(Counting Sort)

항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여 선형시간에 정렬하는 효율적인 알고리즘

data에서 각 항목들의 발생 회수를 세고, 정수 항목들로 직접 인덱스 되는 카운트 배열 count에 저장한다.

**제한사항이 많다**

- 정수나, 정수로 표현할 수 있는 자료에 대해서만 적용 가능. : 각 항목의 발생 회수를 기록하기 위해, 정수 항목으로 인덱스 되는 카운트들의 배열을 사용하기 때문.
- 카운트들을 위한 충분한 공간을 할당하려면 집합 내의 가장 큰 정수를 알아야한다.

#### 시간복잡도

O(n + k) : n은 리스트 길이, k는 정수의 최대값.







